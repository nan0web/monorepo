# Story

## 2025-12-10

It is important to understand the era in which this product is born in order to have the proper context and the most accurate vision of how it has historically unfolded.

Language shapes our consciousness. In different languages we form meanings differently, and they materialise differently.

My childhood language was Russian. When I started programming I quickly realised that Russian is not a logical language. Preserving logic in Russian is extremely difficult because the language itself is distorted and often does not follow its own rules; many words have absurd origins despite belonging to the same lexical family.

Therefore, for programming (besides scripting languages) and for communication with people, English became my primary language. I studied English already at a level higher than B1 in school because I was looking for a more precise and clearer way to express what I wanted to convey, ensuring logical consistency.

I spent a long time communicating in English on all topics related to design, programming, development and documentation. It was simply more convenient, clearer and worked better. I had experience comparing it with Russian.

In 2014 I came to understand that I needed to study Ukrainian very well, even though I understood it, I could not speak it fluently. In Zaporizhzhia most people communicated in Russian, so I could not. Consequently, in 2014 I decided to move to Lviv and study Ukrainian culture more deeply, just as the war between Russia and Ukraine began. I realised that the cause of this aggression was not simply a whim of Putin, but a historical situation where Ukraine was repeatedly occupied by various emperors and tsars.

I understood that the solution to this problem lies in language. Programming, essentially, is communication through programming languages – also languages. The roots of our logical world lie in the word: the first was the *logos* (as it appears in the original Greek of the Bible). I strive to incarnate this logos as efficiently as possible. While delving deeper into Ukrainian, I observed many interesting moments that I still see today.

In Ukrainian word formation I see a much clearer approach to explaining what is happening, both historically and in the present. Today I interact with language models mostly in Ukrainian, because it is the simplest way for me to gauge whether a model can correctly process information in Ukrainian. If it can, I start using that model in programming.

Ukrainian is a highly logical language and, beyond its logic, it is a language of free people.

### The month‑name example

All languages have month names. Typically we name twelve months, though some cultures have more or fewer. In Ukrainian the month names are derived from natural phenomena, unlike Russian or English, which often bear names of emperors or gods.

- **March** (God of war) → **Березень** (Ukrainian) vs. **Март** (Russian, God of war)
- **July** (Emperor) → **Липень** (Ukrainian) vs. **Июль** (Russian, Emperor)
- **August** (Emperor) → **Серпень** (Ukrainian) vs. **Август** (Russian, Emperor)

The Ukrainian list continues with **Січень**, **Лютий**, **Квітень**, **Травень**, **Червень**, **Вересень**, **Жовтень**, **Листопад**, **Грудень**, showing a clear, nature‑based ordering rather than imperial or mythological references.

### Historical calendar quirks

Peter the First introduced celebrations that aligned with Julius Caesar’s calendar, starting on 1 January. Budgets were prepared over two months and had to be finalised by the tenth month for presentation on 1 January. This imperial tradition is not natural for free people. Ukrainians do not follow it and today stand against imperialism in all its forms, including calendar propaganda.

### Language models and freedom

It is crucial that language models trained on the platform also learn what it means to be free. Ukraine is currently enduring hard times in its fight against imperialist ignorance, and we must extend this struggle into the realm of artificial intelligence.

I consider language models to be projections of collective consciousness at a given time. Through them we can develop ideas and communicate logically with society.

This leads to a notion of “digital life after death” for many thinkers (Pythagoras, Socrates, Franko, etc.). Language models today can write code better than most programmers, so we must write free code for free people, maximising its impact.

In the platform’s communications I use Ukrainian, while documentation is always provided both in English and Ukrainian.

### Core idea of the project

The project’s foundation is a decentralized‑crypto‑anarchic network.

1. **Data ownership** – data must belong to its creator. The creator is not only the author but also the rightful holder of the information. Social networks often do not respect this ownership; they delete or block data, leaving us without control.
2. **Network as knowledge base** – the platform can act as a database or connect to user knowledge sources, while social networks become mere distributors.
3. **Open APIs** – we can expose data via APIs or teach platforms like Google to index user sites, allowing authentication and direct connection without replicating data across many networks.
4. **Security** – data must be reliably protected, independent of messengers that store logs or backups. Private correspondence must remain private; totalitarian regimes seek to make it public to suppress dissent.
5. **Public‑key security** – we use SSL certificates as a baseline, acknowledging past SSL weaknesses, while preparing for quantum‑computing threats with post‑quantum algorithms.
6. **Maximum transparency** – publishing public information openly eliminates fear of misuse; public communication is the safest form of security.
7. **Open‑source** – the project is ISC‑licensed, allowing unrestricted use. Open source enables anyone to audit the code, find bugs, and contribute.
8. **Package ecosystem** – we provide packages that fill gaps in Node.js for both server and client (including `lit` web components, React, etc.), along with testing tools (`node:test`, `vitest`, `@nan0web/test`), parsers, and playgrounds.
9. **Playground** – each package includes a sandbox (CLI for Node, Playwright for web) that runs predefined inputs via environment variables, enabling deterministic testing.
10. **Release automation** – `@nan0web/release` updates dependencies, builds, and generates release notes from changelogs, ensuring minimal changes for maximal effect.

In essence, **nan0web** is about making the smallest change produce the greatest result, with language models driving development and open‑source guaranteeing safety and freedom.

---

#### License

The project is distributed under the **ISC** license.

---

*nan0web – minimal changes, maximal result.*  
